all:
 License: "(rsc/LICENSE:Verbatim)"
 WutVersion: "current/0.0.1"
wut:
 Language: "Go"
 Path: "../wutgo"
 SourceFiles: " cmd( [izit.go:Bin] [izit_test.go:Tst] ) [wut.go:Lib] [<encoder>.go:Mod] [LICENSE:License] " 
 Lib: "(rsc/TOPCOMMENT:Comment)[wut:PackageStart][wut:LibImport][<_top_/Provides>:Function]"
 Mod: "(rsc/TOPCOMMENT:Comment)[wut:PackageStart][wut:LibImport][{encoder}:StructureStart][<encoder/Contains>:StructureElement][{encoder}:StructureEnd][<encoder/Provides>:Method]"
 Bin: "(rsc/TOPCOMMENT:Comment)[main:PackageStart][github.com/charlesap/wutgo:Import][main:BinMethod][<_cmd_/Provides>:Function]"
 Tst: "(rsc/TOPCOMMENT:Comment)[test:PackageStart][github.com/charlesap/wutgo:Import][main:TstMethod][<_tst_/Provides>:Function]"
 Meta: ""
 Comment: "// "
 PackageStart: "\npackage ${me}\n"
 LibImport: | 
  import "fmt"
 Import: |
  import "fmt"
  import "flag"
  import "os"
  import "${me}"
 Function: "\nfunc ${me}(<=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>){\n<~~${me_3}~~>\n}"
 Method: "\nfunc (${me_0}) ${me}(<=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>){\n<~~${me_3}~~>\n}"
 ArgLFirst: "${me_0}"
 ArgLNext: " ,${me_1}"
 ArgLE: "${nm} ${tp}"
 BinMethod: |
  func main(){
    vptr := flag.Bool("version",false, "Print the version of izit and exit")
    iptr := flag.String("in","-", "Input File")
    optr := flag.String("out","-", "Output File")
    cptr := flag.String("config","", "Config File")
    eptr := flag.String("encoders","ASE", "Encoders")
    fptr := flag.String("format","csv", "Format")
    flag.Parse()
    if *vptr {
      fmt.Println("Go izit version <~current>:<WutVersion~>")
      os.Exit(0)
    }
    Setup(*iptr,*optr,*cptr,*eptr,*fptr)
    wut.Initialize(true)
    Run(true)
  }
 TstMethod: |
  func main(){
    wut.Initialize(true)
    fmt.Println("testing wut version <~current>:<WutVersion~>")
  }
 StructureStart: "\ntype ${me} struct {"
 StructureEnd: "}"
 StructureElement: "  ${me} <~${me_0}>:<TypeMap~>"
 TypeMap: "Int64/int64 Float64/float64 String/string Bool/bool _nothing_/\"\""
 CodeMap:
   emit: " fmt.Println(${me_r})"
   reserve: "// ${me}"
   if: "// ${me}"
   else: "// ${me}"
   fi: "// ${me}"
   set: "// ${me}"
   call: "// ${me}"
   MERGE: "// MERGE"
 MainModuleRequirements:
 MakeClean: "cd ../wutgo; rm izit"               
 MakeLib: ""                 
 MakeBin: "cd ../wutgo; go build cmd/izit.go"                 
 MakeTest: ""                
 DoTest: |
         cd ../wutgo
         ./izit --version
         ./izit --in - --out - --encoders "CE,SE,RDSE" --format "csv" 
wutpy:
 Language: "Python"
 Path: "../wutpy"
 SourceFiles: " wut( [__init__.py:Lib] [izit.py:Bin] [test.py:Tst] [<encoder>.py:Mod]) [setup.py:Meta] [LICENSE:License] "
 Lib: "(rsc/TOPCOMMENT:Comment)[wut:PackageStart][<encoder>:Import][<encoder/Provides>:Method]"
 Mod: "(rsc/TOPCOMMENT:Comment)[{encoder}:StructureStart][<encoder/Contains>:StructureElement][<encoder/Provides>:ClassMethod]"
 Bin: "(rsc/TOPCOMMENT:Comment)[wut:BinImport][<_cmd_/Provides>:Method][main:BinMethod]"
 Tst: "(rsc/TOPCOMMENT:Comment)[<_tst_/Provides>:Method]"
 Meta: "(rsc/setup.py)"
 Comment: "# "
 PackageStart: "# ${me} Module"
 Import: "from wut.${me} import ${me}"
 BinImport: |
            import argparse
            import ${me}
 xMethod: "\ndef ${me}():\n  pass"
 Method: "\ndef ${me}(<=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>):\n<~~${me_3}~~>"
 ArgLFirst: "${me_0}"
 ArgLNext: " ,${me_1}"
 ArgLE: "${nm} ${tp}"
 BinMethod: |
  if __name__ ==  '__main__':
    p = argparse.ArgumentParser()
 
    p.add_argument("--version", action='store_true', help="Print the version of izit and exit")
    p.add_argument("--inp", nargs='?', const="-", help="Input File")
    p.add_argument("--out", nargs='?', const="-", help="Output File")
    p.add_argument("--config", nargs='?', const="", help="Config File")
    p.add_argument("--encoders", nargs='?', const="ASE", help="Encoders")
    p.add_argument("--format", nargs='?', const="csv", help="Format")
    args=p.parse_args()
    if args.version:
      print("Python izit version <~current>:<WutVersion~>")
      quit()
    Setup( args.inp, args.out, args.config, args.encoders, args.format )
    wut.Initialize(True)
    Run(True)
 StructureStart: "\nclass ${me}:\n  pass"
 StructureElement: "  ${me} =  None"
 ClassMethod: "\ndef ${me}(<=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>):\n  pass\n<~~${me_3}~~>\n"
 TypeMap: "Int64/ Float64/ String/ Bool/ _nothing_/ BitPat/" 
 CodeMap:
   emit: "  print(${me_r})"
   reserve: "  # ${me}"
   if: "  # ${me}"
   else: "  # ${me}"
   fi: "  # ${me}"
   set: "  # ${me}"
   call: "  # ${me}"
   MERGE: "  # MERGE"
 MainModuleRequirements:
 MakeClean: ""               
 MakeLib: ""                 
 MakeBin: ""                 
 MakeTest: ""                
 DoTest: | 
         cd ../wutpy
         PYTHONPATH=$PYTHONPATH:. python wut/izit.py --version
         PYTHONPATH=$PYTHONPATH:. python wut/izit.py --in - --out - --encoders "CE,SE,RDSE" --format "csv"
Wut.jl:
 Language: "Julia"
 Path: "../Wut.jl"
 SourceFiles: " src( [Wut.jl:Lib] [Izit.jl:Bin] [<encoder>.jl:Mod]) test( [runtests.jl:Tst] )  [REQUIRE:Meta] [LICENSE:License] "
 Lib: "(rsc/TOPCOMMENT:Comment)[Wut:PackageStart][<encoder>:PackageInclude][<_top_/Provides>:Method][Wut:PackageEnd]"
 Mod: "(rsc/TOPCOMMENT:Comment)[{encoder}:StructureStart][<encoder/Contains>:StructureElement][{encoder}:StructureEnd][<encoder/Provides>:ClassMethod]"
 Bin: "(rsc/TOPCOMMENT:Comment)[Wut:BinInclude][<_cmd_/Provides>:Method][main:BinMethod]"
 Tst: "(rsc/TOPCOMMENT:Comment)"
 Meta: ""
 Comment: "# "
 PackageStart: "\nmodule ${me}"
 PackageEnd: "end # module ${me}"
 PackageInclude: "include(\"${me}.jl\")"
 Method: "\n\nfunction ${me}(<=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>)\n<~~${me_3}~~>\nend"
 ArgLFirst: "${me_0}"
 ArgLNext: " ,${me_1}"
 ArgLE: "${nm}::${tp}"
 BinInclude: |
             using ArgParse
             import ${me}
 BinMethod: |
            function main()


              s = ArgParseSettings(description = "Izit utility for Wut processing.")
              @add_arg_table s begin
                "--version"
                    action = :store_true
                "--in"
                    default="-" 
                "--out"
                    default="-"       
                "--config"
                    default=""    
                "--encoders"
                    default="ASE"
                "--format"      
                    default="csv"   
              end
              args = parse_args(s) 
              if args["version"] 
                println("Julia izit version <~current>:<WutVersion~>")
              else
                Setup( args["in"], args["out"], args["config"], args["encoders"], args["format"] )
                Wut.Initialize(true)
                Run(true)
              end
            end
            main()
 StructureStart: "\nstruct ${me}"
 StructureElement: "  ${me}::<~${me_0}>:<TypeMap~>"
 StructureEnd: "end"
 ClassMethod: "\nfunction ${me}( me::${me_0},<=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>)\n<~~${me_3}~~>\nend\nexport ${me}"
 TypeMap: "Int64/Int64 Float64/Float64 String/AbstractString Bool/Bool _nothing_/\"\""
 CodeMap:
   emit: " println(${me_r})"
   reserve: "# ${me}"
   if: "# ${me}"
   else: "# ${me}"
   fi: "# ${me}"
   set: "# ${me}"
   call: "# ${me}"
   MERGE: "# MERGE"
 MainModuleRequirements:
 MakeClean: ""
 MakeLib: ""
 MakeBin: ""
 MakeTest: ""
 DoTest: |
         rm /home/cperkins/.julia/v0.6/Wut.jl; ln -s /home/cperkins/go/src/github.com/charlesap/Wut.jl /home/cperkins/.julia/v0.6/Wut.jl
         cd ../Wut.jl/src
         julia ./Izit.jl --version
         julia ./Izit.jl --in - --out - --encoders "CE,SE,RDSE" --format "csv"
wutj:
 Language: "Java"
 Path: "../wutj"
 SourceFiles: " src(main(java( [Wut.java:Lib] [Izit.java:Bin] [Izm.java:Spk] [Test.java:Tst] [<encoder>.java:Mod]))) [pom.xml:Meta] [LICENSE:License] "
 Lib: "(rsc/TOPCOMMENT:Comment)[Wut:PackageStart][<_top_/Provides>:Method][Wut:PackageEnd]"
 Mod: "(rsc/TOPCOMMENT:Comment)[{encoder}:StructureStart][<encoder/Contains>:StructureElement][<encoder/Provides>:ClassMethod][{encoder}:StructureEnd]"
 Bin: "(rsc/TOPCOMMENT:Comment)[Wut:BinImport][Izit:PackageStart][main:BinMethod][<_cmd_/Provides>:Method][Izit:PackageEnd]"
 Spk: "(rsc/TOPCOMMENT:Comment)"
 Tst: "(rsc/TOPCOMMENT:Comment)"
 Meta: "(rsc/pom.xml)"
 Comment: "// "
 PackageStart: "\npublic class ${me}{"
 PackageEnd: "}"
 Method: "\n  public static void ${me}(<=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>){\n<~~${me_3}~~>\n  }"
 ArgLFirst: "${me_0}"
 ArgLNext: " ,${me_1}"
 ArgLE: "${tp} ${nm}"
 BinMethod: |
    // Main Method
      public static void  main(String[] args) throws Exception {

        ArgumentParser parser = ArgumentParsers.newFor("prog").build().description("Process some integers.");
        parser.addArgument("--version").dest("version").action(storeTrue()).help("Print the version and exit");
        parser.addArgument("--in").dest("inf").help("input file");
        parser.addArgument("--out").dest("outf").help("output file");
        parser.addArgument("--config").dest("configf").help("config file");
        parser.addArgument("--encoders").dest("encoders").help("encoders");
        parser.addArgument("--format").dest("format").help("format");
        try {
            Namespace res = parser.parseArgs(args);
            if (res.get("version")){
              System.out.println("Java izit version <~current>:<WutVersion~>\n");
            }else{
              Setup( res.get("in"), res.get("out"), res.get("config"), res.get("encoders"), res.get("format") );
              Wut.Initialize(true);
              Run(true);
            }
        } catch (ArgumentParserException e) {
            parser.handleError(e);
        }


      }
 BinImport: |
            import static net.sourceforge.argparse4j.impl.Arguments.storeTrue;
            import net.sourceforge.argparse4j.ArgumentParsers;
            import net.sourceforge.argparse4j.inf.ArgumentParser;
            import net.sourceforge.argparse4j.inf.ArgumentParserException;
            import net.sourceforge.argparse4j.inf.Namespace;
 StructureStart: "\nclass ${me} {"
 StructureElement: "  public <~${me_0}>:<TypeMap~> ${me};"
 StructureEnd: "}"
 ClassMethod: "\npublic void ${me}( <=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>){\n<~~${me_3}~~>\n}"
 TypeMap: "Int64/int Float64/double String/String Bool/boolean _nothing_/\"\""
 CodeMap:
   emit: " System.out.println(${me_r});"
   reserve: "// ${me}"
   if: "// ${me}"
   else: "// ${me}"
   fi: "// ${me}"
   set: "// ${me}"
   call: "// ${me}"
   MERGE: "// MERGE"
 MainModuleRequirements:
 MakeClean: ""               
 MakeLib: ""                 
 MakeBin: "cd ../wutj; mvn package"                 
 MakeTest: ""                
 DoTest: |
         java -cp ../wutj/target/classes:../wutj/target/argparse4j-0.8.1.jar Izit --version
         java -cp ../wutj/target/classes:../wutj/target/argparse4j-0.8.1.jar Izit --in - --out - --encoders "CE,SE,RDSE" --format "csv"
wutc:
 Language: c
 Path: "../wutc"
 SourceFiles: " [wut.c:Lib] [wut.h:Libh] [izit.c:Bin] [izit.h:Binh] cmd( [test.c:Tst] [test.h:Tsth] ) [<encoder>.c:Mod] [<encoder>.h:Modh] [LICENSE:License] "
 Lib: "(rsc/TOPCOMMENT:Comment)[wut:Import][<_top_/Provides>:Method]"
 Mod: "(rsc/TOPCOMMENT:Comment)[<encoder>:ModImport][<encoder/Provides>:ModMethod]"
 Bin: "(rsc/TOPCOMMENT:Comment)[wut:Import][<_cmd_/Provides>:Method][main:BinMethod]"
 Tst: "(rsc/TOPCOMMENT:Comment)[wut:Import][main:TstMethod][<_tst_/Provides>:Method]"
 Libh: "(rsc/TOPCOMMENT:Comment)[wut:GuardStart][<encoder>:PackageInclude][<_top_/Provides>:LibDef][wut:GuardEnd]"
 Modh: "(rsc/TOPCOMMENT:Comment)[{encoder}:GuardStart][{encoder}:StructureStart][<encoder/Contains>:StructureElement][{encoder}:StructureEnd][<encoder/Provides>:MethodDef][{encoder}:GuardEnd]"
 Binh: "(rsc/TOPCOMMENT:Comment)[wut:Import][<_cmd_/Provides>:MethodDef]"
 Tsth: "(rsc/TOPCOMMENT:Comment)[wut:Import][<_tst_/Provides>:MethodDef]"
 Meta: ""
 PackageInclude: "#include \"${me}.h\""
 Comment: "// "
 Import: |
         #include <stdio.h>
         #include "${me}.h"
         #include "argparse.h"
 ModImport: |
            #include <stdio.h>
            #include "wut.h"
 GuardStart: "#ifndef _${me}_\n#define _${me}_"
 GuardEnd: "#endif"
 xMethodDef: "\nvoid ${me}(<=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>);"
 MethodDef: "\nvoid ${me_0}${me}( ${me_0} me, <=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>);"
 LibDef: "\nvoid ${me}(<=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>);"
 Method: "\nvoid ${me}(<=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>){\n<~~${me_3}~~>\n  }"
 ModMethod: "\nvoid ${me_0}${me}( ${me_0} me, <=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>){\n<~~${me_3}~~>\n  }"
 ArgLFirst: "${me_0}"
 ArgLNext: " ,${me_1}"
 ArgLE: "${tp} ${nm}"
 BinMethod: |
  static const char *const usage[] = {
                "Izit [options] [[--] args]",
                "Izit [options]",
                NULL,
  };


  void main(int argc, const char **argv){

    int version = 0;
    const char *in = NULL;
    const char *out = NULL;
    const char *config = NULL;
    const char *encoders = NULL;
    const char *format = NULL;

    struct argparse_option options[] = {
        OPT_HELP(),
        OPT_GROUP("Basic options"),
        OPT_BOOLEAN('v', "version", &version, "print version and exit"),
        OPT_STRING('i', "in", &in, "input file"),
        OPT_STRING('o', "out", &out, "output file"),
        OPT_STRING('c', "config", &config, "config file"),
        OPT_STRING('e', "encoders", &encoders, "encocers"),
        OPT_STRING('f', "format", &format, "format"),
        OPT_END(),
    };

    struct argparse argparse;
    argparse_init(&argparse, options, usage, 0);
    argparse_describe(&argparse, "\nA brief description of what the program does and how it works.", "\nAdditional description of the program after the description of the arguments.");
    argc = argparse_parse(&argparse, argc, argv);
    if (version != 0){
      printf("c izit version <~current>:<WutVersion~>\n");
    }else{
      Setup( (char *)in, (char *)out, (char *)config, (char *)encoders, (char *)format );
      Initialize(0);
      Run(0);
    }
  }
 TstMethod: "\nvoid main(){\n  Initialize(true);\n  printf(\"testing wut version <~current>:<WutVersion~>\\n\");\n}"
 StructureStart: "\ntypedef struct {"
 StructureEnd: "} ${me};"
 StructureElement: "  <~${me_0}>:<TypeMap~> ${me};"
 TypeMap: "Int64/int Float64/double String/char* Bool/char _nothing_/\"\""
 CodeMap:
   emit: " printf(${me_r});printf(\"\\n\");"
   reserve: "// ${me}"
   if: "// ${me}"
   else: "// ${me}"
   fi: "// ${me}"
   set: "// ${me}"
   call: "// ${me}"
   MERGE: "// MERGE"
 MainModuleRequirements:
 MakeClean: ""               
 MakeLib: "cp rsc/argparse* ../wutc/"                 
 MakeBin: "cd ../wutc; cc -o izit *.c"                 
 MakeTest: ""                
 DoTest: |
         ../wutc/izit --version
         ../wutc/izit --in - --out - --encoders "CE,SE,RDSE" --format "csv"
wutrs:                        
 Language: rust                 
 Path: "../wutrs"             
 SourceFiles: " src( [wut.rs:Lib] [izit.rs:Bin] [<encoder>.rs:Mod]) test( [test.rs:Tst] ) [Cargo.toml:Meta] [LICENSE:License] "
 Lib: "(rsc/TOPCOMMENT:Comment)[wut:PackageStart][<encoder>:LibImport][<_top_/Provides>:Method][wut:PackageEnd]"
 Mod: "(rsc/TOPCOMMENT:Comment)[{encoder}:StdImport][<encoder/Imports>:ModImport][{encoder}:StructureStart][<encoder/Contains>:StructureElement][{encoder}:StructureMid][<encoder/Provides>:ModMethod][{encoder}:StructureEnd]"
 Bin: "(rsc/TOPCOMMENT:Comment)[wut:BinImport][main:BinMethod][<_cmd_/Provides>:Method]"
 Tst: "(rsc/TOPCOMMENT:Comment)"
 Meta: "[ok:MetaText]"
 MetaText: |
           [package]
           name = "wut" # the name of the package
           version = "0.0.1"    # the current version, obeying semver
           authors = ["you@example.com"]
           
           [lib]
           name = "wut"
           path = "src/wut.rs"
           crate-type = ["dylib"]
           
           [[bin]]
           name = "izit"
           path = "src/izit.rs"
                      
           [dependencies]
           argparse = "0.2.1"
           
 Comment: "// "
 StdImport: "use std;"
 LibImport: "mod ${me};"
 BinImport: |
            extern crate ${me};
            extern crate argparse;
 ModImport: "use ${me}::${me};"
 PackageStart: "//{// ${me}"
 PackageEnd: "//}// ${me}"
 Method: "\npub fn ${me}(<=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>){\n<~~${me_3}~~>\n}"
 ModMethod: "\n  pub fn ${me}( &self, <=-${me_1}>-<ArgLFirst:ArgLNext:TypeMap:ArgLE-=>){\n<~~${me_3}~~>  }"
 ArgLFirst: "${me_0}"
 ArgLNext: ", ${me_1}"
 ArgLE: "${nm}: ${tp}"
 BinMethod: |
            use argparse::{ArgumentParser, StoreTrue, Store};

            pub fn main()
            {
                let mut version = false;
                let mut inf = "World".to_string();
                let mut outf = "World".to_string();
                let mut configf = "World".to_string();                
                let mut encoders = "World".to_string();                
                let mut format = "World".to_string();                
                {  // this block limits scope of borrows by ap.refer() method
                   let mut ap = ArgumentParser::new();
                   ap.set_description("izit htm utility.");
                   ap.refer(&mut version)
                   .add_option(&["-v", "--version"], StoreTrue,"Print version and exit");
                   ap.refer(&mut inf).add_option(&["--in"], Store,  "input file");
                   ap.refer(&mut outf).add_option(&["--out"], Store,  "output file");
                   ap.refer(&mut configf).add_option(&["--config"], Store,  "config file");
                   ap.refer(&mut encoders).add_option(&["--encoders"], Store,  "encoders");
                   ap.refer(&mut format).add_option(&["--format"], Store,  "format");
                   ap.parse_args_or_exit();
                }

                if version {
                    println!("rust izit version <~current>:<WutVersion~>");
                } else {                
                  Setup( inf, outf, configf, encoders, format );
                  wut::Initialize(true);
                  Run(true);
                }
            }
 StructureStart: "\npub struct ${me}{"
 StructureMid: "}\nimpl ${me}{"
 StructureEnd: "}"
 StructureElement: "  ${me}: <~${me_0}>:<TypeMap~>,"
 TypeMap: "Int64/i64 Float64/f64 String/std::string::String Bool/bool _nothing_/\"\""
 CodeMap:
   emit: "   println!(${me_r});"
   reserve: "// ${me}"
   if: "// ${me}"
   else: "// ${me}"
   fi: "// ${me}"
   set: "// ${me}"
   call: "// ${me}"
   MERGE: "// MERGE"
 MainModuleRequirements:    
 MakeClean: ""               
 xMakeLib: "cd ../wutrs/src; rustc -A dead_code -A non_snake_case --crate-type=lib wut.rs"                 
 MakeLib: "cd ../wutrs; CARGO_INCREMENTAL=0 RUSTFLAGS=\"-A dead_code -A non_snake_case  -A unused_imports -A unused_variables -C prefer-dynamic\" cargo build"
 xMakeBin: "cd ../wutrs/src; rustc -A dead_code -A non_snake_case izit.rs --extern wut=libwut.rlib"                 
 MakeBin: ""
 MakeTest: ""                
 DoTest: |
         LD_LIBRARY_PATH=$LD_LIBRARY_PATH:../wutrs/target/debug ../wutrs/target/debug/izit --version
         LD_LIBRARY_PATH=$LD_LIBRARY_PATH:../wutrs/target/debug ../wutrs/target/debug/izit --in - --out - --encoders "CE,SE,RDSE" --format "csv"
wutcs:                       
 Language: csharp              
 Path: "../wutcs"            
 SourceFiles: " cmd( [izit.cs:Bin]  [test.cs:Tst] ) [Wut.cs:Lib] [<encoder>.cs:Mod] [LICENSE:License] "
 MainModDef: ""
 Lib: "(rsc/TOPCOMMENT:Comment)[Wut:PackageStart][<encoder>:LibImport][Wut:LibStart][<_top_/Provides>:Method][Wut:LibEnd][Wut:PackageEnd]"
 Mod: "(rsc/TOPCOMMENT:Comment)"
 Bin: "(rsc/TOPCOMMENT:Comment)[Wut:BinImport][izit:BinPackageStart][main:BinMethod][<_cmd_/Provides>:Method][izit:PackageEnd]"
 Tst: "(rsc/TOPCOMMENT:Comment)"
 Meta: ""
 PackageStart: "namespace ${me}\n{"
 LibStart: "  public class ${me}\n  {"
 LibEnd: "  }"
 Comment: "// "
 LibImport: "  //using ${me};"
 BinImport: "using System;\nusing ${me};"
 BinPackageStart: "public class ${me}\n{"
 PackageEnd: "}// ${me}"
 Method: "\n    public void ${me}(){\n    }"
 BinMethod: "\n    static public void Main(string[] args)\n    {\n        //Initialize(true);\n        Console.WriteLine (\"csharp izit version <~current>:<WutVersion~>\");\n    }"
 MainModuleRequirements:    
 MakeClean: "cd ../wutcs; rm *.dll; cd cmd; rm *.exe"               
 MakeLib: "cd ../wutcs; csc -target:library -out:Wut.dll *.cs"                 
 MakeBin: "cd ../wutcs/cmd; csc -reference:../Wut.dll izit.cs"                 
 MakeTest: ""                
 DoTest: "mono ../wutcs/cmd/izit.exe --version"
wutv:
 Language: Verilog
 Path: "../wutv"
 SourceFiles: " [Izit.v:Bin]  [Test.v:Tst] [Wut.v:Lib] [<encoder>.v:Mod] [LICENSE:License] "
 Lib: "(rsc/TOPCOMMENT:Comment)[wut:PackageStart]"
 Mod: "(rsc/TOPCOMMENT:Comment)"
 Bin: "(rsc/TOPCOMMENT:Comment)[main:PackageStart][main:BinMethod][wut:PackageEnd]"
 Tst: "(rsc/TOPCOMMENT:Comment)"
 Meta: ""
 Comment: "// "
 PackageStart: "module ${me};"
 PackageEnd: "endmodule"
 BinMethod: "  initial\n    begin\n      $$display(\"verilog izit version <~current>:<WutVersion~>\");\n      $$finish ;\n    end"
 MainModuleRequirements:
 MakeClean: ""               
 MakeLib: ""                 
 MakeBin: "cd ../wutv; iverilog -o Izit Izit.v"                 
 MakeTest: ""                
 DoTest: "cd ../wutv; vvp Izit --version"
wuths:
 Language: Haskell
 Path: "../wuths"
 SourceFiles: " [izit.hs:Bin]  [test.hs:Tst] [wut.hs:Lib] [<encoder>.hs:Mod] [LICENSE:License] "
 Lib: "(rsc/TOPCOMMENT:Comment)[wut:PackageStart]"
 Mod: "(rsc/TOPCOMMENT:Comment)"
 Bin: "(rsc/TOPCOMMENT:Comment)[main:BinMethod][<_cmd_/Provides>:Method]"
 Tst: "(rsc/TOPCOMMENT:Comment)"
 Meta: ""
 Comment: "-- "
 PackageStart: "-- Package ${me}"
 BinMethod: "main = putStrLn \"Haskell izit version <~current>:<WutVersion~>\""
 Method: "\n-- function ${me}()"
 MainModuleRequirements:
 MakeClean: ""               
 MakeLib: ""                 
 MakeBin: "cd ../wuths; ghc -o izit izit.hs"                 
 MakeTest: ""                
 DoTest: "cd ../wuths; ./izit --version"
wutjs:                          
 Language: Javascript              
 Path: "../wutjs"              
 SourceFiles: " [izit.js:Bin]  [test.js:Tst] [index.js:Lib] [<encoder>.js:Mod] [package.json:Meta] [LICENSE:License] "
 Lib: "(rsc/TOPCOMMENT:Comment)[wut:PackageStart][<encoder>:Import][<_top_/Provides>:Method]"
 Mod: "(rsc/TOPCOMMENT:Comment)[{encoder}:PackageStart][{encoder}:StructureStart][<encoder/Contains>:StructureElement][{encoder}:StructureEnd][<encoder/Provides>:Method]"
 Bin: "(rsc/TOPCOMMENT:Comment)[main:BinMethod][<_cmd_/Provides>:Method]"
 Tst: "(rsc/TOPCOMMENT:Comment)[test:BinMethod][<_tst_/Provides>:Method]"
 Meta: ""
 Comment: "// "
 PackageStart: "\n// Package ${me}"
 Import: "\nimport ${me}"
 BinMethod: "  console.log(\"Javascript izit version <~current>:<WutVersion~>\");"
 Method: "\nfunction ${me}(){\n}"
 StructureStart: "\ntype ${me} struct {"
 StructureEnd: "}"
 StructureElement: "  ${me}"
 MainModuleRequirements:        
 MakeClean: ""               
 MakeLib: ""                 
 MakeBin: ""
 MakeTest: ""                 
 DoTest: "cd ../wutjs; LD_LIBRARY_PATH=/opt/rh/rh-nodejs4/root/usr/lib64:LD_LIBRARY_PATH /opt/rh/rh-nodejs4/root/usr/bin/node test.js --version"                

